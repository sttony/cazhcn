\chapter{$\mathcal {NP}$完全问题}\label{Sec:Chapter:NPCompleteProblem}
\section{概述}
在前面的章节中我们学写了非常多种类的问题和算法。有些算法是很直接的，
但是有些很复杂和需要技巧，但是所有这些算法的复杂性都在$O(n^3)$，这
里n是问题规模定义。从本章的观点来看，我们将接受所有的算法studied so
far as having fairly low time
requirements。再看一眼表\ref{Table:GrowthRateOfFunction}。我们
看到有些算法很复杂以致于不能用简单的多项式描述，这些算法求解一个
大规模的输入运行的时间相当大。表的最后一列展示了如果复杂性是$2^n$，
算法即使对于很小的输入也是没有用的。在这一章里面我们将关注那些指数
复杂度的问题，这些问题对于稍微大一点的输入就需要计算很多年，甚至
好几个世纪。我们将展示一个定义，这个定义区分我们已经碰到
的tractable（"不是很难" \footnote{译注：可控制的，可管理的}）问题
和intractable（"很难"，或是非常耗时的）问题。我们将学习一类重要
的问题，这类问题有一个烦人的属性--至今我们还无法知道他们能不能有效
的解决。已经找到解决这类问题的非精确算，但是没有一个能证明这些问题
需要很多时间。因为许多这类问题是实际应用中频繁提出的优化问题，有效
的算法有重大的现实意义。

\section{$\mathcal {P}$和$\mathcal {NP}$}
本章中“$\mathcal {P}$”是一类问题，他们可以在“多项式时间”内解决。
对于“$\mathcal {NP}$”的描述比较复杂。在得到形式化定义和定理之前，
我们描述几个将贯穿本章的问题。之后我们给出P和NP的定义。
\subsection{决策问题}
本章描述的许多问题都来源于优化问题（他们成为\emph{组合最优化问题}），
但是他们也可以形式化为决策问题。$\mathcal {P}$和$\mathcal {NP}$类
问题，他们将在后面的小节中定义，就是一类决策问题。基本的，一个
\emph{决策问题}是一个只能有两个答案\emph{yes}和\emph{no}的问题。某些
输入可以引起麻烦。一个\emph{问题实例}是问题和特定输入的组合。经常的
一个决策问题有两个部分：
\begin{enumerate}
\item \emph{实例}描述部分定义了除输入外的其他信息。
\item \emph{问题}部分给出了实际的yes或no问题；问题包含了定义在实例描述中的变量。
\end{enumerate}
对于给定的输入决策问题正确的输出不是\emph{yes}就是\emph{no}。因此，决策问题可以
抽象为所有输入到集合{yes,no}的映射。

为了展示为什么输入的精确语句是重要的，考虑下面的两个问题：
\begin{enumerate}
\item \emph{实例：}一个无向图$G=(V, E)$。

      \emph{问题}：G包含一个有k个顶点的clicque吗？（一个clique是完全子图：子图中每一对顶点之间都有边连接。）
\item \emph{实例：}一个无向图$G=(V, E)$和整数k

      \emph{问题：}G包含一个有k个顶点的clicque吗？
\end{enumerate}

两个问题是一样的，但是第一个问题k不是输入的一部分，所以一个实例到另一个
实例k是不能变的；换句话说，k是\emph{常量}。这个问题恰好可以在$O(k^2n^k)$内的
算法解决。如果k是一个常数，算法运行在多项式时间。在第二个问题中，k是一个
输入的一部分，所以它是变量。算法仍然运行在$O(k^2n^k)$，但是这个表达式
不是一个多项式的，因为n的指数是一个变量。

\subsection{一些简单的问题}
我们将在这一章中学习一些问题。在有些情况下问题是实际应用产生问题的简化
或抽象。经常的，困难的问题被简化以尝试做一些改进和得到一些认识，希望这些
认识能用于改进原来的问题。
\begin{definition}
图的着色和彩色数（chromatic number）

图$G=(V, E)$的\emph{着色}是一个映射$C: V \rightarrow S$，这里S是一个有限集合
（“颜色”），如果 则$C(V)\neq C(w)$；换句话说，邻接顶点不能赋以相同的颜色。

G的\emph{彩色数}，表示为$\chi(G)$，是着色图G需要的最小颜色数（就是说，最小
的使G的着色C，$|C(V)|=k$成立的k）。
\end{definition}

\begin{problem}
图的着色

我们给出无向图$G= (V, E)$要求着色。

优化问题：给出G，决定$\chi(G)$（并得出一个最优着色，就是说，一个仅用$\chi(G)$种颜色的着色方案）。

决策问题：给出G和正整数k，有没有一种仅用k种颜色的G的着色？（如果有，称G是k种可着色。）

图的着色问题是特定类型时序安排问题的抽象。例如，假设你的大学的期末考试需要在
一个星期内安排，每天3场考试，即总共有15个“插槽”。有些课程，比如微积分1和
物理1，必须安排在不同的时间，因为有些学生同时修了这两门课。令V是课程的集合，
令E是不恩那个一起考试的课程对的集合。则考试能不冲突的安排在15个插槽中，等价
与图$G=(V ,E)$ 可以用15种颜色着色。
\end{problem}

\begin{problem}
带惩罚的任务调度

假设n个任务$J_1,\cdots, J_n$在一个时刻只能执行一个。我们给出执行时间
$t_1, \cdots, t_n$，和时间期限$d_1, \cdots, dn$（从第一个任务开始的
时间开始计算），和超过时间期限的惩罚$p_1, \cdots, p_n$。假定执行时间，
时间期限和乘法都是正整数。一个任务调度是${1, 2, \cdots, n}$的排列$\pi$，
这里$J_{\pi(1)}$表示首先要做的任务，$J_{\pi(2)}$表示第二要做的任务，
依此类推。

对于一个特定的调度，如果任务的$J_{\pi(2)}$在时间期限$d_{\pi(j)}$之后完成则，
第j的任务的惩罚表示为$P_j$，定义为$P_j=p_{\pi(j)}$，否则$P_j=0$。对于特定的
调度总的惩罚是
\begin{displaymath}
P_\pi=\sum_{j=1}^nP_j
\end{displaymath}

优化问题：决定最小的可能惩罚（并找到最优的调度--有最小的总惩罚）。

决策问题：在输入中给出非负整数k，是否存在一个调度使得$P_\pi \leq k$？
\end{problem}

\begin{problem}
装箱

假设我们有无限个容量为1的箱子，和n个大小$s_1, \cdots, s_n$物体，这里
$0<si\leq 1$（$s_i$是有理数）。

优化问题：决定可以装下物体的最少的箱子数量（并找到最小的装箱方法）。

决策问题：给出整数k，对象是否能装入k个箱子中？

装箱的引用包括，计算机的存储器中packing数据（例如，磁盘扇区上的文件，
程序段中的内存页，不足一个内存字的域）和产品的装填顺序（例如纺织品和木材）
以装入大的标准大小的箱子中。
\end{problem}

\begin{problem}
背包

假设我们有一个容量为C的背包（一个正整数）和n个大小为$s_1, \cdots, s_n$的
物体和“收益”$p_1, \cdots, p_n$（这里$s_1, \cdots, s_n$和$p_1, \cdots, p_n$
是正整数）。

优化问题：找到背包能装下的最大收益（并找到达到这个收益的物体的子集）。

决策问题：给出k，是否存在一个物体的子集能装入背包，且收益超过k？

背包问题在经济计划和装填或是packing问题中有很多应用。例如，背包问题可以描述
投资决定的问题，投资问题中"大小"是一项投资需要的资金，C是总的资金，而投资的
“收益”是期望的回报。在这个问题更复杂版本的应用中，对象是太空飞行中需要
组织的任务或试验。他们的“大小”除了对仪器设备的需要外，还有对能源的需要，
还需要一个小组花时间来执行他们。在太空飞行中，能源，时间都是有限的。每一个
任务有它的价值。那种任务的组合有最大的总价值。
\end{problem}

注意前面的3个问题都是以最小值描述的，但是背包问题是以最大值描述的。下一个问题
是背包问题的简化版本。

\begin{problem}
子集和

输入是一个正整数C和n个物体，物体的大小是正整数$s_1, \cdots, s_n$。

优化问题：选取物体的子集，子集的和小于C，那么最大的子集和是多少？

决策问题：是否存在一个物体的子集，他们的和恰好等于C？
\end{problem}

\begin{problem}
可满足性

一个popositional（或布尔）变量是一个可以赋值为true或false的变量。如果v是
逻辑变量，则 ，非v，是true当且仅当v是false。一个literal\footnote{译注：指合取公式中的一项}
是一个逻辑变量或是逻辑变量的非。一个逻辑公式以递归形式定义，逻辑公式
是表达式，表达式是逻辑变量或是逻辑常量（也就是true和false），或者由
表达式加逻辑运算符组成。一个逻辑公式可以表示为多种形式，包括函数符号
（例如，and(x,y)），运算符符号（例如，($x\wedge y$)），或者表示为一颗树，每一个
internal节点是逻辑运算符，每一个叶子是逻辑变量或者是\emph{true}或\emph{false}。如果
给每一个变量赋值，通过运算符的规则可以给公式计算一个真值。

逻辑公式的一种特定规范形式叫做\emph{合取范式}（\emph{conjunctive normal form}），
使用广泛。子句\emph{clause}是一个由逻辑或（$\vee$）分隔的literals的序列。一个逻辑
公式是合取范式（CNF），当它是由逻辑与（$\wedge$）分隔的子句序列。一个合取范式
的逻辑公式的例子是
\begin{displaymath}
(p\vee q \vee s)\wedge (\overline{q} \vee r) \wedge (\overline{p} \vee r) \wedge (\overline{r} \vee s) \wedge (\overline{p} \vee \overline{s} \vee \overline{q})
\end{displaymath}
这里p，q，r和s都是逻辑变量。贯穿本章“CNF范式”始终指逻辑CNF范式。

一套逻辑变量的\emph{真值赋值truth assignment}是给集合中每一个变量赋予true或false，
换句话说是集合的布尔值函数。一套真值赋值\emph{满足}一个公式，当它使得这个公式的值
为true。注意一个CNF范式被满足，当且仅当它的每一个子句都是真，而子句是真
当且仅当子句中至少一个literal是真。

决策问题： 给出一个CNF范式，存在一个真值赋值满足它吗？

这个决策问题叫\emph{CNF-可满足性}，或简称\emph{可满足性}，经常简写为\emph{CNF-SAT}
或\emph{SAT}。可满足性问题在自动定理证明中使用。这个问题在本章中作为中心例子。

下面的可满足性问题的简化，叫做3-可满足性，3-CNF-可满足性，3-SAT，3-CNF-SAT，
也是很重要的。（我们理出多个名字和简写是因为没有标准的术语，这个问题经常被提及。）

决策问题：给出一个CNF范式，它的每一个子句最多允许3个literals，存在一个真值赋值满足它吗？
\end{problem}

\begin{problem}
哈密顿回路Hamiltonian cycles和哈密顿路径Hamiltonian paths

无向图的哈密顿回路是一个简单的回路，它穿过每一个定点一次且仅一次。有时候使用
词cicuit代替回路。

决策问题：给出一个无向图，它有哈密顿回路吗？

一个相关的优化问题是旅行商问题，或最小漫游路线，下面将描述这个问题。

无向图的哈密顿路径是一条简单路径，它穿过每一个定点一次且仅一次。

决策问题：给出一个无向图，它有哈密顿路径吗？

两个问题都可以推广到有向图，在有向图时他们叫“有向哈密顿回路（路径）问题”。
一个哈密顿回路的变体是指定了开始和结束顶点。
\end{problem}

\begin{problem}
旅行商

这个问题最广泛的名字是旅行商问题traveling salesperson problem（简写为TSP），
但是也叫最小漫游问题minimum tour problem。商人想最小化访问一个区域内所有
城市的费用（时间，或是距离），而且要回到出发点。其他应用包括垃圾收集车的
路线和包裹速递的路线。

优化问题：给出一个完全带权图找到最小权的哈密顿回路。

决策问题：给出一个完全带权图和证书k，存在权最多只有k的哈密顿回路吗？

传统版本将图当作无向的；就是说，边的两个方向的权都是一样的。哈密顿回路问题
也有有向图的版本。
\end{problem}

这些问题的有用性和显而易见的简单可能引起你的兴趣；在行动之前将邀请你设计解决他们的算法。

\subsection{$\mathcal {P}$类}
对于上一小结的问题没有已知的算法能保证在合理的时间内得出结果。我们不会严格
的定义“合理”，但是我们将定义一类P问题，它包括有合理的效率的算法。

\begin{definition}
多项式底限

说一个算法是\emph{多项式底限的}，当它的最坏情况复杂性是输入规模的多项式函数（也就是
当有一个多项式p，使得每一个规模为n的输入，算法都将在p(n)步内终止）。

一个问题是多项式底限的，当它有一个多项式算法。
\end{definition}
第一章到第十二章所有的算法都是多项式低限的，只有少数可选练习除外。

\begin{definition}
$\mathcal{P}$类

$\mathcal{P}$类一类决策问题， 这类问题有多项式的底限。
\end{definition}

$\mathcal{P}$仅定义在决策问题上,but you usually will not go wrong by thinking of
the kinds of problems studied earlier in this book as being in $\mathcal{P}$。

用多项式低限作为分类标准似乎有点奢侈--多项式可以到非常大。但是，有好几个
理由选择多项式。

首先，尽管并不是$\mathcal{P}$类中的每一个问题都有可接受的有效率算法，但是我们可以
说如果一个问题不属于$\mathcal{P}$类，它一定是极度耗时间的，且在实践中几乎是不可解决
的。本小节前面描述的所有问题可能都不属于$\mathcal{P}$类；目前对于这些问题没有已知
的算法能在多项式底限内解决，而且这个领域的大多数研究者相信没有这样的算法存在。
因此虽然$\mathcal{P}$的定义可能太宽泛以致不能作为“问题是否在合理的时间内可解”的
标准，但是它提供了一个有效的标准--不在$\mathcal{P}$中肯定是不可接受的。

其次，将多项式低限作为定义P的原因是多项式有好的“闭包”属性。一个复杂问题的算法
可以通过许多简单问题的算法获得。简单算法可能需要其他算法的输出或是中间结果。加法、
乘法和composition简单算法的复杂性就可以得到复杂算法的复杂性。因为多项式对这些
运算都是闭合的，任何以几个多项式底限的 算法通过自然方式构建起来的算法也是多项式
底限的。没有更小的在用的复杂性低限函数对于这些运算是闭合的。

最后，使用多项式低限使得P独立与使用的计算形式模型。有好几个形式模型（算法的
形式定义）被用于证明算法和问题复杂性的严格定理。这些模型允许的操作类 型，可用的
内存资源和赋予不同操作的消耗都不一样。一个问题在一个模型中需要$\Theta(f(n))$步，
在另一个模型中可能需要多于$\Theta(f(n))$步，但是对于所有的现实的模型，如果
一个问题是多项式底限，那么在别的模型中也是多项式底限。

\subsection{$\mathcal {NP}$类}
许多决策问题（包括我们所有的简单问题）都可以表达成一个存在问题：是否存在图G的k种
颜色着色？是否存在一个真值赋值使得给定的CNF范式为真？对于给 定输入，“解决方案”
是一个对象（例如，一个图的着色，或一个真值赋值），这个对象满足问题的标准从而得到
一个yes回答（例如，图的着色最多用k种颜 色；真值赋值使得CNF范式为真）。
“可能的解决方案”是一个简单的有恰当类别的对象--他可能满足也可能不满足标准。有时
我们使用术语certificate来表示可能的解决方案。宽松的讲，$\mathcal{NP}$是一类决策问题，
对于给定输入的一个可能的解决方案能快速的验证（在多项式时间内）是否是一个真正的
解决方案（即它是否满足问题所有的要求）。更正式一点，问题的输入和可能的解决方案
必须能用来自有限集合的符号串描述，例如，计算机键盘的字符集合。我们需要使用一些
符号来约定对图、集合、函数等等的描述。对于特定问题采用的这套约定称为问题的encoding。
串的大小就是里面符号的数量。所选 集合的符号串不是问题相关的有效编码 ；他们只是
毫无疑义的组合。正式的，一个问题实例的输入和可能的解决方案可以是字符集种的任意串。
验证一个可能的解决方案包括验证串是一个有意义的（就是说，有正确的语法）所需要类别
对象的描述，还有就是要检查它是否满足问题的标准。所以任一字符集的串都可以认为是
问题实例的certificate。

可能有一些决策问题对于“解决方案”和“可能的解决方案”没有自然的解释。抽象的说，
一个决策问题仅是一个函数，函数的输入是一个串的集合，输出是 {yes,no}。$\mathcal{NP}$
的一个形式化定义考虑所有的决策问题。定义使用我们马上将要定义的非确定性算法。尽管
这样的算法在实践中是不现实或是没有用的。， 他们对于分类问题是很有用的。

\begin{definition}
非确定性算法

一个\emph{非确定性算法}有两个阶段和一个输出步：
\begin{enumerate}
\item 非确定性算法“猜”阶段。字符集的有些完整的任意串，s，“写在”内存指定的
    地方。算法运行的每一步，写的串可能不同。（这个串是certificate；它可以认为是
    一个问题解决方案的一个猜测，所以这个阶段称为猜阶段，但是s可能是无意义的串。）
\item 确定性“验证”阶段。一个确定性子例证开始执行。除了决策问题的输入外，
    子例程可能使用s，或可能忽略s。最终它返回\emph{true}或\emph{false}--或者它进入
    死循环不会停止。（认为验证阶段就是检查s，看s是不是决策问题输入的一个解决方案，
    也就是如果它为决策问题的输入得到yes回答。）
\item 输出步。如果验证阶段返回true，算法输出yes。否则没有输出。
\end{enumerate}
\end{definition}

执行非确定性算法一次执行的步数定义为两个阶段步数的和；就是说，步数是写s（简化为
s中字符的数量）加上第二步验证s执行的步数。

我们也可以以一种显式子例程结构描述非确定性算法。假设genCertif产生一个任意的
certificate。
\begin{figure}
\begin{lstlisting}[language={Java},keywordstyle=\color{blue!70}, commentstyle=\color{red!50!green!50!blue!50}]
void nondetA(String input)
{
    String s=getCertif();
    boolean checkOK=verifyA(input, s);
    if(checkOK)
        Output "yes";
    return;
}
\end{lstlisting}
\end{figure}
正式的说，一个算法对于任何输入都应该终止，以及只要给算法同样的输入就一定会有
同样的输出。这对与非确定性算法是不一定的；对于特定的输入x，一次运行 得到的
输出（或者可能没有输出）可能和另一次得到的不一样，因为他们依赖于s。那么一个
非确定性计算对于特定决策问题和特定输入得到的"回答"（称为A）是什么呢？A对于
x的回答定义为yes，当且仅当有些A的运行过程给出了yes输出。如果对于所有s回答
都是no，就没有输出。使用我们s的非正式符号作为一个可能的解决方案。A对于x的
回答是yes，当且仅当有一个可能的解决方案可以“工作”。

\begin{example}
非确定性图着色

假设问题是决定一个无向图是否可以用k种颜色着色。非确定算法的第一阶段将写一个串s，
在第二阶段将其解释为一个可能的着色。串s可以解释为一个整数$c_1,c_2, \cdots,c_q$
的列表，q取决于s的长度。算法第二阶段可以将这些整数解释成颜色赋予顶点：赋值$c_i$
到$v_i$。为了验证着色是否有效，第二阶段还需要：
\begin{enumerate}
\item 检查列表中是否有n种颜色（也就是q=n）
\item 检查每一个$c_i$是否都在$1, \cdots, k$的范围内。
\item 扫描图的边的列表（或者扫描邻接矩阵），对于每一条边$v_iv_j$检查$c_i\neq c_j$；
    也就是一条边的两个顶点的颜色不同。
\end{enumerate}
如果所有的测试都通过，验证阶段返回true，算法输出yes。如果s不满足所有的要求，
验证阶段可能返回false或进入死循环，对于这次执行算法不产生输入。

\begin{figure*}[!t]
    \centering
    \begin{tikzpicture}[scale=1,place/.style={circle,draw, fill=white,inner sep=0pt,minimum size=8mm}]
    \node (x1)  at (0,3) [place] {1};
    \node (x2)  at (-1,1.5) [place] {2};
    \node (x3)  at (1,1.5) [place] {3};
    \node (x4)  at (-2,0) [place] {4};
    \node (x5)  at (2,0) [place] {5};
    \node at(-2, 2) {G};
    \node at(0, -0.7){输入：k=4，n=5，G的边：(1,2)，(1,4)，(2,4)，(2,3)，(3,5)，(2,5)，(3,4)，(4,5)};

    \draw [thick] (x1) -- (x2);
    \draw [thick] (x1) -- (x3);
    \draw [thick] (x2) -- (x4);
    \draw [thick] (x2) -- (x5);
    \draw [thick] (x2) -- (x3);
    \draw [thick] (x3) -- (x4);
    \draw [thick] (x3) -- (x5);
    \draw [thick] (x4) -- (x5);
    \end{tikzpicture}
    \caption{非确定性图着色的输入（例13.1）}
    \label{Fig:Under}
\end{figure*}

举个例子，令输入实例是图13.1中的G，k=4，在这种情况下问题是，“G可以被4种颜色着色吗？”
为了更好的可读性，我们用字母代替数字表示颜色B（蓝）、R（红）、Y（黄）和O（橙）。
这里有一个可能的certificate串s和验证阶段返回值的列表。

\begin{tabular}{lll}
    \hline
    s       &输出    &原因\\
    \hline
    RGRBG   &false   &v2和v5都是绿色且相邻\\
    RGRB    &fasle   &不是所有顶点都着色了\\
    RBYGO   &false   &使用了过多的颜色\\
    RGRBY   &true    &有效的4种颜色着色\\
    R\%*,G@  &false   &错误的语法\\
    \hline
\end{tabular}

既然（至少）有一个结果返回true，所以对于输入（G，4）非确定性算法的回答是yes。

\end{example}

如果对于每一个回答为yes的规模为n的输入有一个（固定的）多项式p，有一些回答
yes的输出最多在$p(n)$步内得到答案，则认为一个非确定性算法有多项式低限。
（If there is a (fixed) polynomial p such that for each input of size n for
which the answer is yes, there is some execution of the algorithm that produces
a yes output in at most p(n) steps，则认为一个非确定性算法有多项式低限。）

\begin{definition}
类$\mathcal{NP}$

$\mathcal{NP}$是一类决策问题，这类问题有多项式低限的非确定性算法。（名字
$\mathcal{NP}$是指"Nondeterministic Polynomially bounded。"）
\end{definition}

\begin{theorem}
图着色、哈密顿回路、哈密顿路径、带惩罚的任务调度、装箱、子集的和问题、背包问题、
满足性和旅行商问题（问题13.1到13.8）都属于$\mathcal{NP}$。

证明  证明是直接的，留在练习中。例如，前面描述的检查图的着色就可以简单的在
多项式时间内完成。
\end{theorem}

\begin{theorem}
$\mathcal{P}\subseteq \mathcal{NP}$

证明  一个决策问题的普通（确定性的）算法是非确定性算法的特例，只有细微不同。
如果A是一个决策问题的确定性算法，只需要令A是非确定性选法的第二阶段，但是
修改A使之只要都输出yes，A就返回true，只要输出no就返回false。A只是忽略第一
阶段写下的串的内容，继续按正常计算。一个非确定性算法可 以在第一阶段做0步工作
（写一个空串），所以如果A运行在多项式时间，那么以带修改过的A做第二阶段的
非确定性算法也能运行在多项式时间。如果A输出 yes，非确定性算法也输出yes，
否则什么也不输出。
\end{theorem}

问题是$\mathcal{P}=\mathcal{NP}$或者说$\mathcal{P}$是$\mathcal{NP}$的真子集吗？
换句话说，对于用非确定性“猜”的方法能在多项式时间解决，但是用普通算法不能
在多项式时间解决的问题，非确定性算法比确定性算法更强大吗？如果一个问题属于
$\mathcal{NP}$，有多项式时间低限p，那么如果我们检查所有长度不超过p(n)的串
（也就是说，为每个可能的串运行一次 非确定性算法的第二阶段），我们就可以
（确定性的）给出正确的答案（yes或no）。检查每一个串需要的步数最多是p(n)。
麻烦是有太多的串要检查。如果我们的字符集包括c个字符，有cp(n)个长度为p(n)的串。
串的数量是n的指数，而不是n的多项式。当然有其他方法解决这个 问题：使用对象的
某些属性和技巧来设计算法，使之不检查所有的可能。例如当排序时，我们不检查
所有的n！种排列。本章讨论的问题的困难是这样的思路还没有 产生有效的算法；
所有已知的算法不是检查所有的可能，就是用来检查工作的技巧还不足以在多项式底限内。

一般都相信$\mathcal{NP}$是一个比$\mathcal{P}$大的集合，但是还没有一个在
$\mathcal{NP}$中的问题被证明不在P中。许多NP中的问题（包括13.2.2小节中所有的
简单问题）都没有已知的多项式低限算法，但是也没能证明这些算法有高于多项式底限。
所以我们前面问到的问题“$\mathcal{P}=\mathcal{NP}$?”，仍然悬而未决。

\subsection{输入的规模}
考虑下面的问题
\begin{problem}\vspace{1ex}
给出一个正整数n，存在整数j,k>1，使得n=jk?（就是说，n是否是非素数？）
\end{problem}
这个问题在$\mathcal{P}$中吗？考虑下面的算法，它查找n的因子。
\begin{lstlisting}[language={Java},keywordstyle=\color{blue!70}, commentstyle=\color{red!50!green!50!blue!50}]
    factor = 0;
    for( j=2; j<n; j++)
    {
        if(( n % j ) ==0)
        {
            factor=j;
            break;
        }
    }
    return factor;
\end{lstlisting}
循环体执行的次数少于n，而且可以确定$(n \mod j)$能在$O(\log^2(n))$内计算，所以算法
的运行时间保守估算是在$O(n^2)$。然而决定一个数是素数或者决定它不是素数的问题，目前
\emph{不知道}是否在$\mathcal{P}$中，而且事实上因子分解大整数的难度是各种密码算法的基础，
因为现在认为这是一个难题。这种矛盾的原因是什么呢？

最初测试算法的输入是整数n，但是n的size是什么？直到现在，我们一直使用任意只要是
方便和合理的输入规模的度量；它对于计数单独的字符s和bits并不重要。当我们度量一个
输入的规模时可能导致一个算法是多项式或是指数的，我们不得不小心对待。输入的规模是
输入写成串的字符的数量。例如，如果n=150， 我们写3个数字，而不是150个数字。因此一个
以十进制表示的整数n有规模约$\log_10n$。如果我们选择数字在计算机内部的表示法--二进制，
那么n的规模约是$\lg n$。两者有一个常数因子的差别；$\log_2n=\log_210\log_10n$，所以
我们使用的数制不是关键。但是关键点是如果输入的规模是$\log_10n$，而算法运行的时间
是n，则算法的运行时间是输入规模的指数函数（$n=10^s$）。因此前面决定n是否素数算法
不属于$\mathcal{P}$。目前没有已知算法能在多项式时间进行素数测试。问题“一个整数n是
否是素数？”属于$\mathcal{NP}$。

在本书前面我们考虑的问题中，我们使用的描述输入规模的的变量对应（多或少）输入数据
的量。例如，我们使用待排序关键字的数量n作为排序问题输入的规模。 每一个待排序关键字
都是以二进制表示的，但是既然有n个关键字，则输入至少有n个符号。所以，如果算法的
复杂性是以n的多项式低限，对于精确的输入规模也是多项式低限。

同样的，我们使用(m+n)作为图输入的规模，但是所有的边需要显式的列出，所以在输入中
至少要m个符号。尽管没有必要在输入中列出所有的n个顶点，在所有的关心每一个顶点的
问题中都会附带上某些边，所以(n+m)最多是输入中符号数量的3倍。进一步的，如果如果
算法的复杂性是以(n+m)的多项式底限，对于精确的输入规模也是多项式底限。

如果两个输入规模的度量中的每一个都在另一个的多项式函数内，则决定问题是否属于
$\mathcal{P}$将依赖于使用那一个度量。以排序问题为例，如果一个度量是关键字的数量n，
第二个是$n\lg(\max key)$（最大以bits数衡量），我们有$n\in O(n\log(\max Key))$和
$n\lg(\max Key)\in O(n^2)$ 。因而每一个度量都在另一个的多项式函数内。

所以我们一般不得不放弃完全精确的输入规模度量。但是我们必须小心行事，尤其当算法
的运行时间以输入\emph{值}表示时是一个多项式函数的时候，如同前面提到的素数测试问题。

前面提到的简单问题中有少数几个有动态规划的解决方法，乍一看似乎有多项式低限，但是
同素数测试问题一样，没有。例如，复习一下\emph{子集和}问题：是否存在n个对象
（大小分别是$s1, s2, \cdots, sn$）的子集其和恰好等于C？使用第十章的技术，可以
用$n\times C$的表格来表示，计算表格的数据只需要很少的步骤（参看练习13.5a）。类似
的不同版本的背包问题也有动态规划解决方案。

子集和问题的动态规划解决方案运行在$\Theta(nC)$。既然输入中有n个对象，n是没有问题
的，但是C的值比输入的指数要大（一般都是），因为C的数据至少需要$\lg C$比特来表示。
因此动态规划解决方案不是一个多项式底限算法。当然，如果C不太大，在实践中算法可能
是有用的。

\section{$\mathcal {NP}$完全问题}
\emph{$\mathcal{NP}$完全}是用来描述NP类中最困难的问题的术语，如果$\mathcal{NP}$完全问题
有多项式低限，则所有的$\mathcal{NP}$问题都应该有多项式低限。

13.2.2小节描述的有些简单问题似乎比其他的简单，事实上，他们的最坏情况复杂性却是不同
（都是快速增长的函数，$2^{\sqrt{n}}$，$2^n$，$(n/2)^{n/2}$，$n!$等），但是令人惊讶
的是，他们是等价的，即如果任一一个属于P，他们都将属于P。他们都是$\mathcal{NP}$完全。

\section{多项式约简Polynomial Reductions}
$\mathcal{NP}$完全的形式化定义使用了约简，或是一个问题到另一个问题的转换。假设我们
想解决问题\textbf{P}且我们已经有另一个解决另一个问题\textbf{Q}的算法。假设我们还有
一个函数\textbf{T}，\textbf{T}接受\textbf{P}的输入x，得到T(x)。使得P正确的输入也
使得Q是\emph{yes}，当且仅当\textbf{Q}对于T(x)是\emph{yes}。则通过
组合\textbf{T}和\textbf{Q}的算法，我们得到一个\textbf{P}的算法。参看图13.2。

\subsection{一些已知的$\mathcal {NP}$完全问题}
\subsection{什么使得问题困难？}
\subsection{优化问题和决策问题}

\section{近似算法}
上百个重要的应用都是$\mathcal{NP}$完全的。如果我们必须解决其中一个我们能做什么？
有很多可能的途径。即使没有多项式底限算法存在，已知算法的复杂性还是有很大的差别；
我们通常可以尝试为一个开发一种最有效率的。我们可以关注平均行为而不是最坏情况
and look for algorithms that are better than others by that ctiterion, or more
realistically, 我们能找到一种算法仅对最经常发生的输入能很好的工作；这个选择
可能更加依赖于经验主义而不是严格的分析。

在这一节里面我们学习解决$\mathcal{NP}$完全优化问题的一种不同的办法：使用
快速（就是有多项式底限）算法，其不保证能得到最优解但是能比较接近最优解。这样
的算法称之为近似算法或是启发式算法。启发是“拇指的规则（rule of thumb）”，就是
通常似乎能找到更好情况的想法，但是可能不能证明确实是好。

在许多应用中一个近似解决方案就足够好了，特别是当需要考虑求解时间时。例如，你
不能通过找到一个最优的任务调度方案来获胜，如果找到最优解的计算时间已经导致了
最糟糕的惩罚的话。

策略或启发，就像他们的名字一样，被许多近似算法用来简化问题，然而他们能提供令人
惊讶的好结果。他们中的许多是贪婪启发。在第8章我们学习了几种贪婪算法他们都得到
了最优解；这一章里面贪婪算法不能得到最优解。为了得到近似算法的精确语句（他们的
结果好的何种程度，不是他们要运行多少时间），我们需要几个定义。再下面的段落中，
假设一个特定优化问题\textbf{P}和也定的输入\emph{I}。

\begin{definition}
可行解决方案集合

一个\emph{可行解决方案（feasible solution）}是一个正确类型的对象，但是不必要是最优的
一个。$FS(I)$是\emph{I}的可行方案集合。
\end{definition}

\begin{example}
可行解决方案集合

对于图着色问题和一个输入图G来说，FS(G)是使用任意数量颜色G的所有有效的
着色的集合。

对于装箱问题和输入$I={s_1,\cdots,s_n}$，$FS(I)$是使用任意数量箱子所有有效的
装箱方案的集合（也就是，all partitions of I into disjoint subsets
 $T1, \cdots,T_p$, for some p, such that total of the si in any subset
 is at most 1.）

对于一个任务调度问题的输入可行的解决方案是n个任务的全排列。
\end{example}

\begin{definition}
价值函数

对于输入实例I，和可行的解决方案x，函数$val(I,x)$返回优化参数的价值。
\end{definition}

\begin{example}
价值函数

\begin{enumerate}
\item 对于图的着色，val(G,C)是着色C使用的颜色数量。
\item 对于装箱问题，如果$T_1, \cdots,T_p$是输入I中对象可行的划分，则
        $val(I,(T_1, \cdots,T_p))=p$，使用的箱子的数量。
\item 对于任务调度，$val(I,\pi)=P_\pi$，调度$\pi$的惩罚。
\end{enumerate}
\end{example}

读者识别可行的解决方案集合以及解决方案的价值函数一定很简单。

\begin{definition}
最佳价值

依赖于具体问题，我们想找到一个解决方案，其最小化或是最大化的\emph{价值}；
令“最好”是分别是“最小”或是“最大”。则$opt(I)=best{val(I,x)|x \in FS(I)}$ 。
就是说，它是所有可行的解决方案能达到的最好的价值。\emph{I}的一个\emph{最佳价值}
是$FS(I)$中的x有$val(I,x)=opt(I)$。
\end{definition}

\begin{definition}
近似算法

一个问题的近似算法是多项式时间算法，它对于输入I，输出FS(I)的一个元素。
\end{definition}

这里有好几种方式描述近似算法的质量。通常最有用的是算法输出的价值和最优解决方案
的比值（尽管有时我们可能想看看两者之间的绝对差别）。令\textbf{A}是一个近似算法。
我们用\textbf{A(I)}表示为输入I选择一个可行的解决方案\textbf{A}。我们定义：
\begin{equation}
r_A(I)=\frac{val(I, A(I)}{opt(I)}  \qquad \mbox{对于最小化问题}
\end{equation}

\begin{equation}
r_A(I)=\frac{opt(I)}{val(I, A(I)}  \qquad \mbox{对于最大化问题}
\end{equation}

在两种情况下，$r_A \geq 1$。为了总结\textbf{A}的行为，我们将考虑最坏情况的比率。

\section{装箱}
装箱问题是一类问题的简化，这类问题在实践中经常遇到：如何组合或存储不同大小
不同形状的对象，使得浪费的空间最小。

\section{背包}
\subsection{排序算法的判定树}
\section{图的着色}
\subsection{一些基础技术}
\subsection{近似图着色是困难的}
\subsection{Wigderson's图着色算法}

\section{TSP旅行商问题}
对于旅行商问题（TSP），我们给出一个完全带权图，我们想找到一个有最小权的漫游
路线（经过所有顶点的回路）。这个问题在路由和调度问题中有大量的应 用。所以从
理论上和实践上对这个问题的研究热情都很高。本小节展示一些简单的近似算法，然后
给出一个定理（没有证明）这个定理指出大概一个好的近似算法不太可能存在。
\subsection{贪婪策略}
在第8章我们学习了两种在带权无向图中找最小生成树的贪婪算法（Prim's算法和
Kruskal's算法）。两个算法都能自然简单变成的TSP问题的算法。在这一小节中，
我们降考察这些方法。

复习优化问题的贪婪方法，由一个选择序列组成，其中每一个选择都朝向最好的“短期目标”，
而这些“短期目标”是容易计算的。一旦作出了选择，就不能撤销， 即使后来的事实证明
这是一个糟糕选择。一般的，贪婪策略有启发：启发似乎朝好的方向去，但是其中有很多
并不总是导向最优解决方案或者并不总是有效率。在第 8章，我们能证明Prim's和Kruskal's
对最小生成树的贪婪策略总是能有效率的产生最优解决方案。

复习Prim's算法，它从一个任意顶点开始，生成一颗树。在主循环的每一个迭代步骤它选
一条已在树中顶点到边缘顶点之间的边；它“贪婪的”的选择权最小的。

另一方面，Kruskal's算法“贪婪的”从图中剩下的边中选择权最小的，且不能和已选择的
边构成回路的边。Kruskal's算法任意时刻选出来的边构成的子图可以不是连同的；它是
森林，不必要是树（最后必须是树）。

TSP问题对应的贪婪策略s分别叫做最近邻居策略和最短连接策略。

\subsection{最近邻居策略}
\emph{最近邻居策略}相当的简单。在Prim's算法中，当我们选择一条新边，我们能从树
的任一顶点分支。这里我们构造的是回路不是树，所以我们

\subsection{最短连接策略}

\subsection{TSP的近似算法有多好？}
不必惊讶这些简单的多项式时间TSP策略不能产生最小权的漫游路线。我们已经说了TSP是
NP完全，可能没有算法能在多项式时间解决。（当然这不是说最近邻居策略和最短连接策略
总是不能产生最优漫游路线，有时他们碰巧能产生最小权的漫游路线。）

最近邻居策略和最短连接算法是TSP的近似算法。我们能建立这两个算法产生的漫游路线的
权和最优漫游路线的权之间差的底限吗？不幸的是，不能。考虑下面的定理。

\begin{theorem}
令\textbf{A}是任一TSP问题的近似算法。如果有任一常量c对于所有实例\emph{I} 都有
$rA(I)\leq c$，则有$\mathcal {P}=\mathcal {NP}$。

证明  参看本章后面的Notes和References。
\end{theorem}

这个定理说“保证”好的TSP的近似算法不太可能存在，就像不太可能存在TSP的多项式时间
算法一样--即使“好”定义的非常宽松，允许为最优漫游路线的权乘上任意常数因子。但是，
如果我们以特定的属性约束输入的图，then there are approximation algorithms for the
 TSP with bounds on the weight of the tours produced。例如，如果图的边的权表示
 机场之间的距离，则应该满足三角不等式：
\begin{equation}
W(u,v)\leq W(u,v) + W(v, w)   \mbox{对于所有G中的u,v,w都成立}
\end{equation}

练习13.53描述TSP的一个近似算法，如果图满足三角不等式，它保证了产生权最多是
最优解两倍的漫游路线。
\section{DNA计算}
当我们听到\emph{计算机（computer）}时，我们想到的是现代的电子计算机。但是这个
词有许多其他的含义。几个世纪以来，computer指那些靠计算为生的人。计算技术的发展
从手指开始（计数），到各种机械装置（算盘，加法机，卡片排序机），直到现代的电子
计算机（从上十吨的庞然大物到桌上的个人计算机，到便携的嵌入系统）。没有理由认为
计算机技术的发展会终止。下一代是什么？可能是基于DNA，或生物技术的计算机。

\subsection{DNA背景}
DNA是脱氧核糖核酸，编码生物特征的基因的原料。这篇简单的背景介绍是为了更好的
理解DNA是怎么应用到计算上的。从生物学的角度看，它稍微有点简单，有点不严密。

DNA由一串化学上称为核苷的物质组成。DNA中有4种核苷，每一种以名字的第一个字母
表示：腺嘌呤（adenine A）、胞核嘧啶（cytosine C）、鸟嘌呤（guanine G）和胸腺
嘧啶（thymine T）。我们可以用4个字母编码出任何信息，就像我们能用0和1编码出任何
信息一样。现在可能合成包含特定核苷序列的DNA线；就是说创建任意表示数据的串。

John Waston和Francis Crick发现了DNA的双螺旋结构（这项工作为他们赢得了Nobel奖）。
核苷构成互补对：A和T互补，C和G互补。如果两根核苷线在对应的位置有互补的核苷，两条
核苷线相互依附（且在双螺旋结构中互相缠绕）。例如，参看图13.16（我们展示了依附在一起的核苷线，但是不是双螺旋的）。互补线互相依附
的事实在哈密顿路径的DNA算法中反复用到。有可能发生两条线即使在有些位置不互补也能依附在一起；这是DNA处理的一个属性，这可能导致麻烦。

Kary Mullis，一个化学家，开发了称为聚合酶链反应polymerase chain reaction（PCR）
的process，它复制小的DNA样本。（现在PCR在基因研究和forengsics中广泛使用，
而Mullis也因为这项工作赢得了Nodel奖。）寻找符合我们要求的线的算法中，好几步都
用到了PCR。算法每一步使用的实际生物过程是复杂的，但是我们不得不理解他们以理解算法的逻辑。因此这都是我们需要的背景。


\subsection{Adleman的有向图和DNA算法}
\subsection{分析和评估}
