\chapter{排序}\label{Sec:Chapter:Sort}

\section{概述}

在本章中我们将学习几个排序的算法，就是将集合中的元素按顺序排列。将一组
元素排序的问题是第一个广泛研究的计算机科学问题。已知最好的分而治之的许
多算法设计范例都是排序算法。在20世纪60年代，当商业数据处理大规模的变的
自动化的时候，在安装计算机的地方排序程序是运行的最多的程序。

\section{插入排序}\label{Sec:InsertSort}
\subsection{策略}
\subsection{算法和分析}

\section{分而治之}
\section{快速排序}
快速排序是最早发现的分而治之算法；它由1962由C.A.R.Hoare发表。
直到现在它也是实际使用中最快的算法之一。
\subsection{快速排序的策略}
\subsection{Partition 子例程}
\subsection{快速排序的分析}
\subsubsection{最坏情况}
Partition把每一个关键字与pivot比较，所以如果在它工作的范围有k个位置，它
将做k-1次比较（第一个位置是空位）。如果E[first]是要分割范围最小的元素，
则splitPoint=first，这将导致分割成一个空的子范围（没有元素比pivot小）和
一个k-1个元素的子范围。因此所以，每次Partition调用时如果pivot是最小的元素，
则总的比较次数是
\begin{displaymath}
    \sum_{k=2}^n=\frac{n(n-1)}{2}
\end{displaymath}
这与插入排序和Max排序一样坏。而且奇怪的是，最坏情况在关键字已经有序的
时候发生！快速排序是不是有点虚假广告的味道？

\subsubsection{平均行为}
\subsubsection{更精确的平均行为*}
\subsubsection{空间使用}
\subsubsection{}

\subsection{基本快速排序算法的实现}
\subsubsection{选择枢轴}
\subsubsection{可选的Partiton策略}
\subsubsection{小集合排序}
\subsubsection{堆栈空间优化}

\section{归并有序序列}
\section{归并排序}
\section{基于比较的排序的底限}
\subsection{排序算法的判定树}
\subsection{最坏情况的底限}
\subsection{平均行为的底限}
\section{堆排序}\label{Sec:HeapSort}
\subsection{堆}
\subsection{堆排序的策略}
\subsection{修正堆}
\subsection{构造堆}
\subsubsection{正确性}
\subsubsection{最坏情况分析}
\subsection{堆的实现和堆排序}
\subsubsection{堆排序分析}
\subsection{加速堆排序}
\subsubsection{分析}
本质上，
\section{四种排序算法的比较}
\section{Shell排序}\label{Sec:ShellSort}
\subsection{算法}
\subsection{分析和注意事项}

\section{基数排序}
对于\ref{Sec:InsertSort}到\ref{Sec:ShellSort}的排序算法，对于关键字的假设
只有一个：他们是线型的集合。基本的操作是比较两个关键字。如果我们对关键字
作更多的假设，我们能可以对关键字做其他的操作。本节学习一种新的算法，叫
“桶排序”，“基数排序”或是“分配排序”
\subsection{使用关键字的属性}
假设关键字是打印在卡片上的名字，一个卡片一个名字。为了将他们按字母排序分类
