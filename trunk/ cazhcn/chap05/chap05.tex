\chapter{Selection and Adversary Arguments}\label{Sec:Chapter:SelectionandAdversaryArguments}
\section{概述}
在这章中我们学习几个可以被归类到一个通用名字\emph{selection}的问题。找到
一个集合的中间元素是一个总所周知的例子。除了找到有效解决问题的算法，
我们还将找到这类问题的\emph{底限}。我们会介绍一种被称为adversary
arguments的广泛应用的技术来建立底限。

\subsection{Selection问题}
假设E是包含n个元素的数组，数组元素的关键字属于某个线型集合，令k是
的一个整数。selection问题是找到E中第k小的元素。这样的元素叫做有\emph{rank
k}。与我们学过的排序算法一样，我们将假定唯一的操作是比较两个关键字
（以及拷贝或是移动元素）。在这一章中关键字和元素是一样的，因为我们
注意的是关键字比较的次数，而且我们一般不关心元素移动。还有，当关键字
在一个数组中存放时，我们将使用位置$1, \cdots,n$而不是$0,\cdots
,n-1$以符合一般的rank术语，位置0只是简单的放在那里不用。

在第一章中我们解决了一个k=n的selection问题，那个问题是简单的找到最大
的元素。我们考虑了一个最简单的算法做了n-1次关键字比较，之后我们
证明了没有算法可以低于这个值。对于查找最小的元素，即k=1解决方法是一样
的。

另一个常见的selection问题是$k=\lceil n/2 \rceil$
，就是找到中间的元素，或者叫median元素。median对于概括一个大的集合的
数据是很有用的，比如一个国家中所有人的收入或是某个职业的收入，房子的
价格或是大学入学考试中的分数。例如新闻报道不是用包含所有数据的集合，
而是告诉我们一个平均值。可以在$\Theta(b)$内简单的计算n个元素的平均值
吗？我们如何才能有效的计算平均值？

当然，所有的selection问题都可以通过对E排序来解决；之后无论我们想要rank
k，E[k]就是解。排序需要$\Theta(n\log
n)$次比较，我们可以知道对于有些值k，selection问题可以在线型时间内解决。
直觉上讲似乎找到median是selection问题中最难解决的。我们可以在线型时间
内找到median吗？或是我们能建立一个找到median的底限吗，可能是$\Theta(n
\log n)$
？我们将在本章回答这个问题，我们还将描述一个selection问题的框架算法。
\subsection{底限}
目前为止我们已经将判定树作为建立低限的主要手段。算法判定树的内部节点
表示了算法要执行的比较的次数，而叶子表示了输出。
（\ref{Sec:SearchInOrderArray}节的查找算法中，内部节点同样表示输出。）
最坏情况下比较的次数是树的高度；对于L个叶子，高度至少是$\lceil \lg L
\rceil$。

在\ref{Sec:SearchInOrderArray}节中我们使用判定树得到最坏情况下查找问题
的低限是$\lceil
\lg(n+1)\rceil$。这是二分查找的精确比较次数，所以判定树给出了最好可能
的低限。在第\ref{Sec:Chapter:Sort}章我们使用判定树来得到排序的低限是$\lceil
\lg n!\rceil$ 或是粗略解$\lceil n\lg n -1.5n\rceil$
。有些算法非常接近这个底限，再一次的，判定树给出了非常可信的结果。
但是，判定树对于selection问题就不是很好用了。

一个selection问题的判定树至少有n个叶子因为集合中n个关键字中的每一个都
可能是输出，即第k小的值。因此我们得出树的高度（最坏情况下的比较次数）至少
是$\lceil \lg
n\rceil$。但是这不是一个好的低限；我们已经知道在最简单的情况下查找
最大的元素需要至少n-1次比较。判定树在那里错了呢？在查找最大元素的判定树
中，有些输出出现至少在多个叶子上，事实上将有多于n个叶子。参考练习5.1，将
要求你画出FindMax（算法1.3）在n=4时的判定树。因为我们不知道一种简单的
方法知道一个结果到底包含多少重复的叶子，所以判定树不能给出好的低限。

代替判定树，我们用一种叫adversary
argument的技术来为selection问题建立更好的低限。这种技术喜爱下面描述。

\subsection{Adversary Arguments}
假设我们和朋友玩一个猜谜游戏。你选出一个时间（月份和日期），朋友将
通过问是/不是来猜这个时间。你必须迫使你的朋友问尽可能多的问题。如果
第一个问题是，“是在冬天吗？”而你是一个好的对手，所以你回答“不是”，
因为3个季节比一个季节要多。对于问题，“月份的第一个字母在字母表的
前半吗？”你回答“是”。但是这是欺骗吗？你根本没有选出一个真实的
日子！事实上，你不会选出一个确定的月和日期，直到为了不让你的答案
前后矛盾位置。这不是一个玩猜谜游戏的好方法，但是它在找一个算法的底限
时是个正确的方法。

假设我们有一个算法，我们认为它是有效的。想象有一个对手想证明它不是
有效的。在每一个算法做判定的点（例如一次关键字比较），对手告诉我们
判定的结果。对手选择它的回答使得算法更难找到结果，就是说要做更多的
判定。你可以认为对手逐渐构造一个算法的“坏”的输入。对手的回答的唯一
限制是必须前后一致；就是必须\emph{有}输入可以使对手的回答是正确的。如果
对手可以迫使算法执行$f(n)$ 步，则$f(n)$
就是最坏情况下算法执行步数的底限。在练习5.2中对排序和归并的关键字
比较进行了分析。

事实上，“设计对抗对手”在解决基于比较的问题时通常是一个有效的技术。

\subsection{竞标赛}
在本章剩下的部分我们解决selection问题的算法，并用adversary
arguments来讨论各种情况的低限，包括median。在大多数算法和arguments
中，我们使用比赛或是竞标赛，来描述比较的结果。比较找到的大的称为\emph{胜者}，
小的称为\emph{败者}。

\section{查找max和min}

\section{查找第二大的关键字}
我们找到并去除最大的元素，然后在剩下的集合中找到最大的，这样就找到了
次大的元素。还有更有效法的方法吗？我们可以证明一个方法是最优的吗？
本小节回答这些问题。

\subsection{概述}
\subsection{竞标赛方法}
\subsection{An Adversary Lowe-Bound Argument}
\subsection{查找max和secondLargest竞标赛方法的实现}

\section{Selection问题}
假设我们想找到一个数组E中n个元素的中间的元素（我们想元素有rank$\lceil
n/2
\rceil$）。在前面的小节中，我们找到了有效的方法找到rank接近一端或是另一端
（比如最大，最小，同时最大最小，次大的）的方法。练习探索了很多变种，但是
所有的解决这些问题的技术在我们不是对付一端的情况时都将失去效率，对于查找
median都没有用。如果我们找到一个解决方案可以有效的简单排序整个集合，则需要
新的思想。


\subsection{一个分而治之接近}
假设我们能将关键字分成两个集合，$S_1$和$S_2$，这样所有在$S_1$
中的关键字都小于$S_2$ 中的关键字。则

\section{查找median的低限}
\section{Designing Against an Adversary}
