\chapter{动态集和查找}\label{Sec:Chapter:DynamicSetAndSearch}
\section{概述}
动态集合是在计算规程中它的关系会改变的集合。在有些应用程序中，集合
一开始是空的，在计算的过程中元素一个个加入。通常集合可能的最大规模
预先是不知道的。另一种应用程序一开始有一个大的集合，在计算过程中逐
步删除元素（通常在集合为空的时候结束）。有些应用程序既删除也添加元
素。开发了许多数据结构来表示动态集合。那种数据结构更有效率依赖于需
要的操作和访问模式。首先我们描述数组成倍增长技术，它是一个基本工具。
接着我们引为amortized时间分析的基础，，这是一项为了展示各种动态集合
实现的效率的常用的技术。最后我们考察许多流行的用来表示动态集合的数
据结构。他们作为适当的ADT的实现而出现。

红-黑树提供了一种平衡二叉树的形式，它对于有效的实现二叉查找树是很
有用的。二叉查找树和hash表是字典ADT的两种流行实现。

动态等价关系在许多应用中存在，它们的操作与Union-Find
ADT紧密相关。使用In-Tree ADT，在一些情况下是非常高效的实现。

优先级队列是许多算法的工具，尤其是贪婪算法。对优先级队列ADT两种
高效的实现是二叉堆（也用于堆排序）和pairing
forests，也称为lazy pairing heaps。

本章将介绍这些主题。为了进一步阅读和更深层次的学习，请参考本章后面的
Note和References。


\section{数组翻倍}
引起动态集合并的典型情况是我们在计算开始时并不知道序列的大小。尽管
分配一个“尽可能大”的序列是常用的方法但并不总是令人满意的。简单的
说，采用灵活的方法初始化一个较小的序列当空间明显不足时就加倍。对这项
工作我们必须明确当前序列有多满和当前已分配了多少条目。Java通过length域
自动明确了后一个信息，对前一个参数是程序员的责任，它依赖于对使用序列
的应用。

假设我们组织了一个类setArray，有两个域setSize和elements，然后把它作为
一个序列元素的类型，我们简单称之为对象。初始化，我们如下在这个类中构造
一个对象：
\begin{lstlisting}[language={Java},keywordstyle=\color{blue!70}, commentstyle=\color{red!50!green!50!blue!50}]
    setArray mySet= new setArray();
    mySet.setSize=0;
    mySet.elements=new Object[100];
\end{lstlisting}
在每次向mySet中添加元素的时候，setSize都将增加。但是在插入新元素之前，
都要确保有空间,若不存在空间，则要把序列长度加倍。这是通过分配一个大小
是当前序列大小2倍的新序列，然后把所有元素转到新序列，这个应用的代码如下：
\begin{lstlisting}[language={Java},keywordstyle=\color{blue!70}, commentstyle=\color{red!50!green!50!blue!50}]
    if(mySet.setSize==mySet.element.length)
        arrayDouble(mySet);
    Continue with insertion of new element;
\end{lstlisting}
在arrayDouble子过程如下：
\begin{lstlisting}[language={Java},keywordstyle=\color{blue!70}, commentstyle=\color{red!50!green!50!blue!50}]
    arrayDouble(set)
    newLength=2*set.elements.length;
    newElements=new Object[newLength];
    Transfer all elements from the
        set.elements array to the newElements array;
    Set.elements=newElements;
\end{lstlisting}

花费大的部分是转移元素。然而，我们在头部插入n个元素入集合，用这种方式存储$O(n)$。
假设插入第(n+1)个元素将触发数组增倍操作，设t为从旧数组转移到新数组的花费
（我们设t是常数）。在数组增倍操作要进行n次转移，在前一次操作中是n/2次操作，
再前一次n/4，等等。所有的转移花费不会超过2tn。

这是可以分期清偿的简单例子，操作的代价偶尔会很昂贵，所以平均每次操作都会被一个
常数所限制。Amortized时间分析将在下面解释。

\section{Amortized 时间分析}
\section{红黑树}
\subsubsection{Properly Drawn树}
\subsubsection{空树作为external节点}
\subsection{二叉查找树}

\subsection{二叉树的旋转}
\subsection{红黑树的定义}
\subsection{红黑树的大小和深度}
\begin{lemma}
令T是一个$RB_k$树。就是说，令$T$是一个有black height h的红黑树。则：
\begin{enumerate}
\item $T$至少有$2^k-1$个internal黑节点。
\item $T$至少有$4^k-1$个internal节点。
\item 任一黑结点的深度约两倍于它的black depth。
\end{enumerate}

令A是$ARB_k$树。就是说，令$A$是一个有black height h的近似红黑树。则：
\begin{enumerate}
\item $A$至少有$2^k-2$个internal黑节点。
\item $A$至少有$\frac{1}{2}4^k-1$个internal节点。
\item 任一黑结点的深度约两倍于它的black depth。
\end{enumerate}

\end{lemma}
\subsection{红黑树中插入}

\section{哈希}
\section{动态等价关系和联合查找程序}
\subsection{动态等价关系}
\subsection{一些浅显的实现}
\subsection{联合－查找程序}
\subsection{Weighted Union}
\subsection{路径压缩}
\subsubsection{wUnion和cFind的兼容性}
\subsection{*wUnion和cFind的分析}
\subsection{应用}

\section{优先级队列with a Decrease Key Operation}
\subsection{The Decrease Key Operation}
