\chapter{图的最优化问题和贪婪算法}
\section{概述}
本章中，我们将学习许多图的可以被贪婪算法精确解决的最优化问题。典型的，
在最优化问题中需要做一系列的选择，以取得最小的消耗，或者得到最大的收益。
贪婪方法由一系列选择组成，每一个单独的选择都使结果向“短期”\footnote{译注：局部的}
最优解靠近，通常局部最优解不需要很多花费就可以得到。一旦作出了一个选择，
它不能被撤销，即使都后面发现它其实是一个糟糕的选择。由于这个原因，
贪婪算法对很多问题不能找到精确的最优解。但是，对于本章讨论的问题我们可以
证明适当的贪婪策略会产生最优的解决方案。在第十三章中，我们将看到非常类似的贪婪
方法无法得到一些问题的解。在第十章中我们也将看到一些贪婪方法不能解决的问题。

本章首先给出一个无向图中找最小生成树的算法，由R.C.Prim给出；一个很相关的
在有向和无向图中找最短路径的算法，由E.W.Dijkstra给出；以及第二个找最小
生成树的算法，由J.B.Kruskal给出。所有的算法使用优先权队列来从候选集合中
选择当前最好的选择。

\section{Prim最小生成树算法}\label{Sec:PrimMST}


\subsection{最小生出树的定义和例子}
\begin{definition}
最小生成树

连通无向图G=(V,
E)的最小生成树是G的一个子图，它是一颗无向树且包含G的所有顶点。在带权图G=(V,
E,
W)上，子图的权是子图所有边的权的和。带权无向图的最小生成树（简写为MST）是权最小的生成树。
\end{definition}

\begin{figure*}[!t]
    \centering
    XXXXXXXXXXXXXXXX
    \caption{一个图和它的一些生成树：其中两个是最小生成树。}
    \label{Fig:BasicControlStructure}
\end{figure*}

\subsection{算法的概况}
\subsection{最小生出树的属性}
\subsection{Prim's MST算法的正确性}
\subsection{用优先权队列有效的管理边缘}
\subsection{实现}
算法主要的数据结构（除了图本身以外）
\subsection{分析（时间和空间）}
\subsection{The Pairing Forest Interface}
\subsection{底限}

\section{单源最短路径}\label{Sec:single-source-shortest-path}
在7.2小节中我们简要的考虑了在航空路线图上如何找到两个城市间最好的路线的问题，
比如图7.8。使用的标准是我们关心的机票的价格，我们观察最好的--就是说最便宜的--从
San Diego到Sacramento的方式是在Los Angeles中转一下。这是一个非常普通的带权图
的问题的实例，或叫应用：在两个特定的顶点之间找到最小权的路径。

最坏情况下，基本上成了两个问题：找到一对特定顶点s和t之间的最小权路径；找到
从s到每一个可以从s到达的顶点的最小权路径。这两个问题一样的复杂。后一个问题叫
做单源最短路径问题。两者采用同样的算法。

本节考虑在带权有向图和无向图上找从一个源顶点到每一个其他顶点最小权路径的问题。
路径的权（长度或是耗费）是路径上所有边的权的和。当权被解释成距离时，一个最小权
路径叫做最短路径，而且这是最常用的名字。（唉，它混合了术语权，耗费和长度。）

我们是如何确定图7.4中SD到SAC的最短路径的呢？事实上，对于这个简单的例子我们使用
了很不规则的方法，充满了假设，比如城市之间的费用和距离是成比例的，地图是按比例
精确画的。则我们捡了一条看上去短的路线，然后加起来了耗费。最后，我们检查了许多
其他的路线（somewhat haphazardly）没有注意到有改进，所以我们宣布问题解决了。这是
一个很难用于计算机编程的算法。我们发现这确实能诚实的回答上面的问题；人们一般
使用非常不严格的方式来解决问题，特别是对非常小的数据集合。

实践中，当V中包含上百，上千，甚至百万个顶点的时候，在图中找最短路径的问题就麻烦
了。理论上算法必须考虑所有可能的路径而且比较他们的权值，但是实践中这可能需要很长
的时间，可能有几个世纪。为了尝试找到更好的方法，找到最短路径的一些通用的性质是
很有帮助的，然后再来看他们是否能发现一个更有效的方法。我们展示的算法是
E.W.Dijkstra提出的。这个算法需要边的权都是非负的。其他一些不需要这个限制的算法
在本章后面的Notes和References中提到。



\subsection{最短路径的属性}
一般的，当尝试解决一个大问题的时候，我们想把它分解成小的问题。What can we say
about shortest paths between distant nodes, in terms of shortest paths between
less distant nodes? 我们可以使用某种形式的分而治之方法吗？假设路径P是x到y的
最短路径而Q是y到z 的最短路径。那么是否意味着P接上Q就是x到z的最短路径？不用很长
的时间就可以找出一个例子来说明它不对。但是它的逆命题是对的。下面的引理的证明留到
练习中。

\begin{lemma}
（最短路径的属性）在带权图G中，假设x到y的最短路径由从x到y的路径P和从y到z的
路径Q组成。则P是x到y的最短路径，Q是y到z的最短路径。
\end{lemma}

假设我们要尝试找x到z的最短路径。可能一条直接的边xz存在，且提供了最短的路径。但是，
如果最短的路径包含2条或更多的边，则引理告诉我们它可以被分解成两条路径，每一条比
原来包含的边少，每一条都是自己的最短路径。为了发展这个算法，我们需要建立一些分解路径
的有组织的方案。

\subsection{Dijkstra's最短路径算法}\label{Sec:Dijkstra}
本小节中我们学习Dijkstra's最短路径算法；它非常类似与前一小节的Prim's最小生成树算法。

\begin{definition}\vspace{1ex}
令P是一条带权图上G=(V, E, W)上的非空路径，由k个边$xv_1, v_1v_2, \cdots, v_{k-1}y$
（可能$v_1=y$）。P的权，表示为$W(p)$是权$W(xv_1), W(v_1v_2), \cdots, W(v_{k-1}y)$。
如果x=y，认为x到y有空路径。空路径的权是0。

如果x到y没有路径的权小于$W(p)$，则P称为最短路径，或是最小权路径。
\end{definition}

前面的定义小心的表达了负权的可能性。但是，在本节中我们假定权是非负的。在这个限制下，
最短路径可以限制成一条简单路径。

\begin{problem}
单源最短路径

给出带权图G=(V, E, W)和一个源顶点s。问题是找出s到每一个顶点v的最短路径。
\end{problem}

在开始之前，我们必须考虑我们是否需要一个全新的算法。假设我们使用最小生成树的算法，
从s开始。由算法构造的树中到v的路径是否就是s到v的最短路径？考虑图8.4中最小生成树
中A到C的路径。它不是最短路径；路径A,B,C更短。

Dijkstra's最短路径算法通过增加到s的距离来找s到其他顶点的最短路径。算法，类似于
8.2小节的Prim's MST算法，从一个顶点（s）开始，通过选择到新顶点的特定的边来“向外分支”。
由算法生成的树叫最短路径树。（叫这个名字不意味着它就是；必须证明在树中的路径
确实是最短路径。）

同样类似于Prim's MST算法。Dijkstra's算法是贪婪算法；它总是选择出现的“最近”的
顶点的边；但是这里的“最近”是到s最近，而不是“到树最近”。顶点被分成3（不相交）
部分如下：
\begin{enumerate}
\item \emph{树}的顶点：当前在树中的，
\item \emph{边缘}的顶点：不在树中，但是与树中的顶点邻接，
\item \emph{没有检查}的顶点：剩下的全部。
\end{enumerate}
同Prim's算法一样，我们记录唯一的到边缘顶点的候选边（当前找到最好的）。对每一个
边缘顶点z，这里至少有一个树中的顶点v，使得vz是G的一条边。对于每一个这样的v都有
（唯一的）树中的从s到v的路径（可能s=v）；d(s, v)表示路径的权。添加一条边vz到
这条路径，，得到s到z的路径，它的权是d(s,v)+W(vz)。z的候选边是vz，因为d(s,v)+W(vz)
是当前所有树中颗选择顶点最小的。

\begin{example}
最短路径树的增长

看图8.9(a)的图。每一个无向边都被看作是……………………………………….
\end{example}

Dijkstra's 算法的一般结构如下：\\
dijkstraSSSP(G,n)\\
\indent    初始化所有的顶点为\emph{没有检查}。\\
\indent     从指定的源顶点s开始树；将其作为树的根；\\
\indent     定义d(s,s)=0。\\
\indent     将所有邻接的顶点划成\emph{边缘}。\\
\indent     当还有边缘顶点时：\\
\indent \indent         在树的顶点t和边缘顶点v中选择一条边，使得d(s,t)+W(tv)最小；\\
\indent \indent         将v划到\emph{树}顶点；将边tv添加到树；\\
\indent \indent         定义d(s,v)=(d(s,t)+W(tv))。\\
\indent \indent         将所有邻接v的\emph{没有检查}顶点划成\emph{边缘}顶点。\\

因为d(s,y)+W(yz)作为候选边可能重复使用，它可以被计算一次并保存。为了有效的计算
它当yz第一次变成候选边时，我们也为树中的每一个y保存d(s,y)。因此我们可以使用
数组dist：
\begin{lstlisting}[language={Java},keywordstyle=\color{blue!70}, commentstyle=\color{red!50!green!50!blue!50}]
    dist[y]=d(s,y);          //`树中的y`
    dist[z]=d(s,y)+W(yz);    //`对于在边缘的z，yz是z的候选边`
\end{lstlisting}
就像在Prim's算法中，在一个顶点和相应的候选边被选择之后，在数据结构中的信息
必须为某些边缘顶点和以前的没有检查顶点更新。

\begin{example}
更新距离信息

在图8.9(d)中……………….
\end{example}

这个方法正确吗？关键的步骤是选择下一个边缘顶点和候选边。对于任意候选边
yz，d(s,y)+W(yz)并不必须是s到z的最短距离，因为到z的最短路径可能不穿过y。
（例如在图8.9中，到H的最短路径并不经过G，尽管GH是c,d和e的可选的一部分。）我们
认为，如果d(s,y)是每一个树顶点y的最短距离，在所有候选边中选出最小的d(s,y)+W(yz)
从而选出了yz，则yz就是给出的最短路径。这个观点在下面的定理中证明。

\begin{theorem}
令G=(V, E, W)是一个带非负权的图。令V`是V的一个子集，令s是V`是的成员。假设d(s,y)
是G中s到每一个$y\in V'$的最短的距离。如果为了使d(s,y)+W(yz)最小选择边yz，
其中y在V`中，z在V-V`中，则由s到y的最短的路径更上yz就是s到z的最短路径。

证明 看图8.10。假设e=yz被选择，令$s, x_1, \cdots, x_r, y$是s到y的最短路径
（可能y=s）。令$P=s, x_1, \cdots, x_r, y, z$。W(P)=d(s,y)+W(yz)。令
$s, z_1, \cdots, z_\alpha, \cdots, z$是s到z的最短路径；叫$P'$。顶点$z_\alpha$
是$P'$中不在$V`$中的第一个顶点（可能za=z）。我们必须说明$W(p)\leq W(P')$。
（如果$a=1$，$z_0=s$，算法将选择$z_{\alpha-1}z_\alpha$。）因为选择了e
\begin{equation}
    W(P)=d(s,y)+W(e)\leq d(s,z_{\alpha-1})+W(z_{\alpha-1}z_\alpha)
\end{equation}
由于引理8.5，$s, z_1, \cdots, z_{\alpha-1}$是s到$z_{\alpha-1}$的最短路径，
所以这条路径的权是$d(s, z_{\alpha-1}$ 。既然$s, z_1, \cdots, z_{\alpha-1}, z_\alpha$
是$P'$的一部分，且每条边都是非负的，
\begin{equation}
d(s, z_{\alpha-1})+W(z_{\alpha-1}z_\alpha)\leq W(p')
\end{equation}
联合(8.2)（8.3），$W(p)\leq W(P')$。
\end{theorem}

\begin{theorem}
给出一个带非负权的图G和源顶点s，Dijkstra's算法计算出s到G中每一个可到达顶点
的最短距离（最小权的路径的权）。

证明 通过将顶点不断加到最短路径树的序列来证明。细节留到8.16中。
\end{theorem}

\subsection{实现}
\subsubsection{分析}
对于8.2.7小节对Prim's最小生成树算法，算法8.1，的分析可以不做任何改变搬到对Dijkstra's
最短路径算法，算法8.2，上来。Dijkstra's算法在最坏情况下也运行在$\Theta(n^2)$。
同样的低限$\Omega(m)$，空间需求也是$\Theta(n)$。

如果不可到达顶点的数量很多，则预处理的时候测试可到达性会更有效率，消除不可
到达顶点，对可到达的重新编号$1, \cdots, n_r$。总的消耗是$\Theta(m+n_r^2)$，
而不是$\Theta(n^2)$。


\section{Kruskal's 最小生成树算法}\label{Sec:KruskalMST}
令G=(V, E, W)是有向带权无向图。\ref{Sec:PrimMST}节中我们学习了找图G最小生成树的
Prim's算法（G必须是连通图）。算法从任意顶点开始，通过“贪婪的”选择最小
权的边不断分支出树。任何时候加入一条边都是一颗树。这里我们检查另一种用
贪婪策略的算法。本节中所有的图都是无向图。
\subsection{算法}
Kruskal's算法的一般思想如下。每一步它都在图剩下的边中选一条权最小的，但是
丢弃与已选择的边构成回路的。任意时刻选择的边都可能相距很远，使得形成森林，而
不必须是树。当所有边都处理过之后算法终结。
\begin{figure}
\begin{lstlisting}[language={Java},keywordstyle=\color{blue!70}, commentstyle=\color{red!50!green!50!blue!50}]
    kruskalMST(G, n)
    {
        R=E;
        F=`空集合`;
        while(R`非空`)
        {   `移除R中权最小的边，比如vw`;
            if(`vw不在F中形成回路`)
                `添加vw到F`;
        }
        return F;
    }
\end{lstlisting}
\end{figure}
在考虑如何实现这个思想之前，我们必须问它是否能工作。既然图可以不是连通的，
我们首先需要一个定义。

\begin{definition}
生出树集合

令G=(V, E, W)是带权无向图。G的\emph{生出树集合}是一个树的集合，每一棵树都是G的
一个连同分量，集合中的树都是连同分量的生成树。\emph{最小生成树集合}是生成树集合
中，边权的和最小的生成树的集合，就是说是最小生成树的集合。
\end{definition}

首先，G的每一个顶点都在某棵树中吗（如果图是非连通的，就可能有多棵树）？令v
是G的任一顶点。如果至少一条边连在v上，令S是附加在v上所有边的集合，则第一条
从S中取走的边将加入F。但是如果v是孤立顶点（没有边与之相连），则它将不出现在
F中，而且没有忽略它的话，需要单独考虑。

下一个问题是算法生成的是否是生成树集合，假设G没有孤立顶点。就是说，对G的每一个
连通分量F中是否都有一棵精确的树？下面的引理提供了这个问题的一些理解。证明
是简单的，留在练习中。

\begin{lemma}
令F是森林；就是任意无向无环图。令e=vw是不在F中的边。如果e和F中的边构成回路，
当且仅当v和w属于F的同一个连通分支。
\end{lemma}

现在假设G的有些连通分量对应Kruskal's算法得到的森林F中的两棵或两棵以上的树。
G中必然存在边连接这两颗树，称为vw；v和w属于F不同的连通分支。因此，当算法
处理边vw时，它必然会得到F'，F'在森林中有回路存在。所以vw不会添加到F'。
由于引理8.8，v和w

\subsection{分析}
