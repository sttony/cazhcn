\chapter{并行算法}\label{Sec:Chapter:ParallelAlgorithm}
\section{概述}
整本书中我们用到的大部分计算模型都是通用的、确定性的、随机访问的计算机，
这种计算机在一个时刻只能执行一个操作。有几次我们建立特定的模型来为特定的
问题得出低限；这些不是通用计算机，但是他们也只能在一个时刻只能执行一个
操作。我们将使用\emph{顺序算法}这个术语来描述到目前为止我们学过的这种一个时刻
执行一步的所有算法。（他们有时候也被称为\emph{串行算法}。）在这一章里面
我们将考虑并行算法，即在一个时刻可以有多个操作并行的执行，也就是说，在
同一时刻对于一个问题有多个处理机在工作。

最近，随着多处理机系统变得便宜，连接多处理机的技术越来越先进，建立一个
包含大量处理机的通用并行计算机称为可能。本章的目的就是介绍这些概念、形式化模型、
技术和并行计算领域的算法。

并行算法对于许多应用程序来说是自然的。在图象处理处理中（例如，机器人的视觉
系统）不同的场景可以同时处理，也就是并行的处理。并行可以加速图象显示的计算。
在搜索问题中（例如，文献搜索、扫描新的故事和文本编辑），数据库或文本的不同部分
可以平行的搜索。模拟程序经常要对被模拟系统中的大量的小部分做同样的计算；这些
在每一个模拟步中都可以并行。人工智能程序（可能包含图象处理和大量的搜索）也可以
从并行中得到好处。快速傅立叶变换（12.4节）以专门的并行硬件实现。许多组合优化
问题的算法（比如第13章描述的NP完全问题的优化版本）含有对巨大数量方案的检查；
有些工作可以并行做。在其他应用领域并行计算也能简单的坚实的加速计算。


\section{并行，PRAM和其他模型}
如果并行计算机中处理机的数量很少，比如2个或6个，则
\subsection{PRAM}
一个\emph{并行随机访问机器}（parallel random access machine PRAM，读作"p ram"）
包含p个通用处理器，$P_0,P_1, \cdots, P_{p-1}$，所有这些处理器都连接在一个巨大
的共享的随机访问的存储器M上。这个存储器笨当作一个（非常巨大的）整数数组
（参看图14.1）。处理器有私有的，或者局部的存储器用于他们自己的计算，但是他们
之间所有的通信都是通过共享存储器实现的。除非我们特别指出，算法

\subsection{其他模型}
尽管PRAM为在并行机器上开发和分析算法提供了一个良好的framework，但是以实际硬件
提供这个模型是困难或者是价格昂贵的。PRAM假定了一个 复杂的通信网络，这个网络允许
所有的处理器在同一处理周期访问任一内存单元，并且能在同一处理周期写任一单元。
因此任一处理器能都能在两个处理周期内与另 一个处理器通信：一个处理器在一个处理
周期将数据写入内存的一个位置，另一个处理器在下一个处理周期读那个内存位置。其他
的并行模型没有这么一个共享内 存，因此限制处理器之间的通信。一个非常贴近实际
硬件的模型是超立方体（hypercube）。一个超立方体有2d个处理器，这里d是维度，
每一个处理器都和它临近的处理器连接。图14.2(a)展示了一个维度是3的超立方体。每一个
处理器都有自己的内存，且能通过消息传递与其他处理器通信。 每一个处理周期，每一个
处理器都可以做计算，然后发消息给它相邻的一个邻居。为了与一个不邻接的处理器通信，
处理器必须发送一个带路由信息的消息，消息中 指名了最终目的地；消息最多需要d次传递
到达目的地。在一个有p个处理器的超立方体中，每一个处理器和lgp个其他的处理器相连。

另一类模型叫做有限度网络（bounded-degree networks），这种模型更进一步的限制连接。
在有限度网络中，每一个处理器最多直接与d个其他处理器连接，d是常量。对于有限度网络
有不同的设计； 图14.2(b)展示一个8×8网络。超立方体和有限度网络比PRAM更贴近现实，
但是他们的算法难以规范和分析。处理器之间消息的路由本身就是一个有趣 的问题，而这
在PRAM中是不存在的。

PRAM，虽然不是非常实际，但是开发算法的时候PRAM是一种概念简单的模型。因此对于如何
在其他的并行模型上模拟PRAM有很多努力，特别是那些不共享内存的模型。例如，每一个
PRAM处理周期都能以大约$O(\log p)$个有限度网络的处理周期模拟。所以我们能为PRAM
开发一种算法，而且知道这个算法能被转换成实际机器的算法。这个转换可以通过转换
程序自动进行。

在第13章中，我们定义了P类问题来帮助区分


\section{一些简单的PRAM算法}
在这一节中我们将引入一些PRAM计算使用的通用技术，还将开发一些简单的算法，两者
都说明了一些PRAM算法的“flavor”，也都提供了后面使用的一些blocks和子例程
（subroutine）。
\subsection{二分扇入技术}
考虑在n个关键字的数组中查找最大关键字的问题。我们对于这个问题有两个算法：
算法\ref{Algo:FindMaxValue}和在5.3.2小节中描述的竞标赛方法。在算法
\ref{Algo:FindMaxValue}中，我们顺序的将剩下的关键字与已经找到的max比较。每次
比较之后，max可能改变；我们不能并行的做下一次比较，因为我们不知道该使用那一个
max。但是在竞标赛方法中，元素在“一轮比赛”中分组，比较。在成功的“一轮比赛”里面，
胜者进入下一轮比赛（参看图5.1）。最大的关键字在$\lceil \lg n\rceil$轮找到。
一轮中的所有比较都能同时执行。因此，竞标赛方法自然的是一个并行算法。

在竞标赛方法中，每一轮需要考虑的关键字的数量都会减半，因此每一轮需要的处理器
的数量减半。但是为了保持算法描述的的简短和清晰，我们在每一处理周期为所有的处理器
指定相同的指令。额外工作可能让人糊涂，所以首先看看图14.3是有帮助的。图14.3展示
了实际需要的工作。直线代表读操作。折线表示写操作；一个处理器写（它能看到的
最大关键字）到与处理器对应的内存单元（例如Pi写到M[i]）。圆圈表示二元操作“比较”
两个值；这里它是比较选出两个关键字中大的。"Bookkeeping"computations fit in
around the reads and writes.如果读线从Pi到Pj的列，意味着Pi从M[j]读，也就是Pj写
的地方。图14.4展示了所有处理器活动的一个完整的例子。阴影部分对应图14.3，这些
部分是影响结果的计算。

\section{处理写冲突}
PRAM模型根据他们如何处理写冲突而变化。CREW（并行读，排他写）PRAM模型要求每一步
中只有一个单元只有一个处理器能写；同一时刻多于一个处理器写一个单元的算法是非法
的。

有几种方法放宽CREW的限制，去掉限制后就是CRCW（并行读并行写）模型（）。
\begin{enumerate}
\item 在公共写模型中，同一时刻多个处理器写一个单元是合法的当且仅当他们写的是
        一个值。
\item 在任意写模型中，当多个处理器同时写一个内存单元时，他们中的任意一个写成功。
        算法必须在无论哪个处理器赢得了写冲突的时候都能保证工作正常。
\item 在优先级写模型中，多个处理器试图同时写一个内存单元时，有最小索引的处理器
        能写成功。
\end{enumerate}
这些CRCW模型成功的得到加强，而且他们都比CREW要强：一个对于前面的模型是合法正确
的算法对于后面的都是合法和正确的，但是反之则不然。

模型的不同在于他们在解决不同的问题的时候速度不一样。为了展示这些区别，我们考虑计算n
bits上的布尔or函数的问题。

\subsection{n bits上的布尔or}
用算法14.1的二分扇入方案，每一个处理器每一轮对1对bits执行or运算，问题在
$\Theta(\log n)$时间内解决。这种方法
\subsection{一个在常数时间查找最大值的算法}
